# Numpy 배열은 동일한 자료형을 가지는 값들이 격자판 형태로 있는 것.
# 각각의 값들은 튜플(양의 정수만을 요소값으로 갖는다.) 형태로 색인 됨.
# rank는 배열이 몇 차원인지를 의미.
# shape는 각 차원의 크기를 알려주는 정수들이 모인 튜플

import numpy as np

a = np.array([1, 2, 3])  # rank가 1인 배열 생성
print(type(a))  # <class 'numpy.ndarray'>
print(a.shape)  # (3,) 1행 3열
print(a[0], a[1], a[2])  # 1 2 3
a[0] = 5  # 요소 변경
print(a)  # [5 2 3]

b = np.array([[1, 2, 3], [4, 5, 6]])  # rank가 2인 배열 생성
print(b.shape)  # (2, 3) 2행 3열
print(b[0, 0], b[0, 1], b[1, 0])  # 1 2 4

a = np.zeros((2, 2))  # 모든 값이 0인 2행 2열의 배열 생성
print(a)  # [[ 0.  0.]
          #  [ 0.  0.]]

b = np.ones((1, 2))
print(b)  # [[ 1.  1.]]

c = np.full((2, 2), 7)  # 모든 값이 7인 배열 생성
print(c)  # [[7 7]
          #  [7 7]]

d = np.eye(2)  # 2x2 단위행렬 생성
print(d)  # [[ 1.  0.]
          #  [ 0.  1.]]

e = np.random.random((2, 2)) # 임의의 값으로 채워진 배열 생성
print(e)  # [[ 0.56634737  0.94887718]
          #  [ 0.48152236  0.22157585]]

# 배열 인덱싱(Array indexing)
# 슬라이싱(Slicing)
a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])

# 슬라이싱을 이용하여 첫 두 행과 1열, 2열로 이루어진 부분배열을 만들어 봅시다;
# b는 shape가 (2,2)인 배열이 됩니다:
# [[2 3]
#  [6 7]]
b = a[:2, 1:3]

# 배열의 중간 행에 접근하는 두 가지 방법이 있습니다.
# 정수 인덱싱과 슬라이싱을 혼합해서 사용하면 낮은 rank의 배열이 생성되지만,
# 슬라이싱만 사용하면 원본 배열과 동일한 rank의 배열이 생성됩니다.
row_r1 = a[1, :]    # 배열a의 두 번째 행을 rank가 1인 배열로
row_r2 = a[1:2, :]  # 배열a의 두 번째 행을 rank가 2인 배열로
print(row_r1, row_r1.shape)  # [5 6 7 8] (4,)
print(row_r2, row_r2.shape)  # [[5 6 7 8]] (1, 4)

# 열의 경우에도 마찬가지
col_r1 = a[:, 1]
col_r2 = a[:, 1:2]
print(col_r1, col_r1.shape)  # [ 2  6 10] (3,)
print(col_r2, col_r2.shape)  # [[ 2]
                             #  [ 6]
                             #  [10]] (3, 1)


# 인덱싱
a = np.array([[1, 2], [3, 4], [5, 6]])

# 정수 배열 인덱싱의 예.
# 반환되는 배열의 shape는 (3,)
print a[[0, 1, 2], [0, 1, 0]]  # [1 4 5]

# 위에서 본 정수 배열 인덱싱 예제는 다음과 동일
print np.array([a[0, 0], a[1, 1], a[2, 0]])  # [1 4 5]

# 정수 배열 인덱싱을 사용할 때,
# 원본 배열의 같은 요소를 재사용할 수 있다.
print a[[0, 0], [1, 1]]  # [2 2]

# 위 예제는 다음과 동일합니다
print np.array([a[0, 1], a[0, 1]])  # [2 2]
