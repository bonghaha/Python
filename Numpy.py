# Numpy 배열은 동일한 자료형을 가지는 값들이 격자판 형태로 있는 것.
# 각각의 값들은 튜플(양의 정수만을 요소값으로 갖는다.) 형태로 색인 됨.
# rank는 배열이 몇 차원인지를 의미.
# shape는 각 차원의 크기를 알려주는 정수들이 모인 튜플

import numpy as np

a = np.array([1, 2, 3])  # rank가 1인 배열 생성
print(type(a))  # <class 'numpy.ndarray'>
print(a.shape)  # (3,) 1행 3열
print(a[0], a[1], a[2])  # 1 2 3
a[0] = 5  # 요소 변경
print(a)  # [5 2 3]

b = np.array([[1, 2, 3], [4, 5, 6]])  # rank가 2인 배열 생성
print(b.shape)  # (2, 3) 2행 3열
print(b[0, 0], b[0, 1], b[1, 0])  # 1 2 4

a = np.zeros((2, 2))  # 모든 값이 0인 2행 2열의 배열 생성
print(a)  # [[ 0.  0.]
          #  [ 0.  0.]]

b = np.ones((1, 2))
print(b)  # [[ 1.  1.]]

c = np.full((2, 2), 7)  # 모든 값이 7인 배열 생성
print(c)  # [[7 7]
          #  [7 7]]

d = np.eye(2)  # 2x2 단위행렬 생성
print(d)  # [[ 1.  0.]
          #  [ 0.  1.]]

e = np.random.random((2, 2)) # 임의의 값으로 채워진 배열 생성
print(e)  # [[ 0.56634737  0.94887718]
          #  [ 0.48152236  0.22157585]]

# 배열 인덱싱(Array indexing)
# 슬라이싱(Slicing)
a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])

# 슬라이싱을 이용하여 첫 두 행과 1열, 2열로 이루어진 부분배열을 만들어 봅시다;
# b는 shape가 (2,2)인 배열이 됩니다:
# [[2 3]
#  [6 7]]
b = a[:2, 1:3]

# 배열의 중간 행에 접근하는 두 가지 방법이 있습니다.
# 정수 인덱싱과 슬라이싱을 혼합해서 사용하면 낮은 rank의 배열이 생성되지만,
# 슬라이싱만 사용하면 원본 배열과 동일한 rank의 배열이 생성됩니다.
row_r1 = a[1, :]    # 배열a의 두 번째 행을 rank가 1인 배열로
row_r2 = a[1:2, :]  # 배열a의 두 번째 행을 rank가 2인 배열로
print(row_r1, row_r1.shape)  # [5 6 7 8] (4,)
print(row_r2, row_r2.shape)  # [[5 6 7 8]] (1, 4)

# 열의 경우에도 마찬가지
col_r1 = a[:, 1]
col_r2 = a[:, 1:2]
print(col_r1, col_r1.shape)  # [ 2  6 10] (3,)
print(col_r2, col_r2.shape)  # [[ 2]
                             #  [ 6]
                             #  [10]] (3, 1)


# 정수 배열 인덱싱
a = np.array([[1, 2], [3, 4], [5, 6]])

# 정수 배열 인덱싱의 예.
# 반환되는 배열의 shape는 (3,)
print(a[[0, 1, 2]])  # [[1 2]
                     #  [3 4]
                     #  [5 6]]
print(a[[0, 1, 2], [0, 1, 0]])  # [1 4 5]

# 위에서 본 정수 배열 인덱싱 예제는 다음과 동일
print(np.array([a[0, 0], a[1, 1], a[2, 0]]))  # [1 4 5]

# 정수 배열 인덱싱을 사용할 때,
# 원본 배열의 같은 요소를 재사용할 수 있다.
print(a[[0, 0]])  # [[1 2]
                  #  [1 2]]
print(a[[0, 0], [1, 1]])  # [2 2]

# 위 예제는 다음과 동일합니다
print(np.array([a[0, 1], a[0, 1]]))  # [2 2]

# 정수 배열 인덱싱 유용하게 사용하는 방법 :
# 행렬의 각 행에서 하나의 요소를 선택하거나 바꾸는 것
a = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])

print(a)
# [[ 1  2  3]
#  [ 4  5  6]
#  [ 7  8  9]
#  [10 11 12]]

# 인덱스를 저장할 배열 생성
b = np.array([0, 2, 0, 1])

# b에 저장된 인덱스를 이용해 각 행에서 하나의 요소 선택
print(a[np.arange(3)])
# [[ 1  2  3]
#  [ 4  5  6]
#  [ 7  8  9]

print(a[np.arange(4), b])  # [ 1  6  7 11]

# b에 저장된 인덱스를 이용해 각 행에서 하나의 요소를 변경
a[np.arange(4), b] += 10

print(a)
# [[11  2  3]
#  [ 4  5 16]
#  [17  8  9]
#  [10 21 12]]

# 불리언 배열 인덱싱
# 특정 조건을 만족하게 하는 요소만 선택할 때 유용
a = np.array([[1, 2], [3, 4], [5, 6]])

bool_idx = (a > 2)  # 2보다 큰 a의 요소를 찾는다;
print(bool_idx)
# [[False False]
#  [ True  True]
#  [ True  True]]

# 참 값을 가지는 요소로 구성되는 rank 1인 배열 출력
print(a[bool_idx])  # [3 4 5 6]

# 한 문장으로
print(a[a > 2])  # [3 4 5 6]


# 배열 연산
x = np.array([[1, 2], [3, 4]], dtype=np.float64)
y = np.array([[5, 6], [7, 8]], dtype=np.float64)

# 요소별 합
# [[  6.   8.]
#  [ 10.  12.]]
print(x + y)
print(np.add(x, y))

# 요소별 차
# [[-4. -4.]
#  [-4. -4.]]
print(x - y)
print(np.subtract(x, y))

# 요소별 곱
# [[  5.  12.]
#  [ 21.  32.]]
print(x * y)
print(np.multiply(x, y))

# 요소별 나눗셈
# [[ 0.2         0.33333333]
#  [ 0.42857143  0.5       ]]
print(x / y)
print(np.divide(x, y))

# 요소별 제곱근
# [[ 1.          1.41421356]
#  [ 1.73205081  2.        ]]
print(np.sqrt(x))

# Numpy에선 벡터의 내적, 벡터와 행렬의 곱, 행렬곱을 위해 'dot'함수를 사용.
x = np.array([[1, 2], [3, 4]])
y = np.array([[5, 6], [7, 8]])

v = np.array([9, 10])
w = np.array([11, 12])

# 벡터의 내적
# 219
print(v.dot(w))
print(np.dot(v, w))
print(np.dot(w, v))

# 행렬과 벡터의 곱; rank 1인 배열 [29 67]
print(x.dot(v))
print(np.dot(x, v))

# 행렬곱; rank 2인 배열
# [[19 22]
#  [43 50]]
print(x.dot(y))
print(np.dot(x, y))

# sum
x = np.array([[1, 2], [3, 4]])
print(np.sum(x))  # 모든 요소를 합함. 10
print(np.sum(x, axis=0))  # 각 열 합 [4 6]
print(np.sum(x, axis=1))  # 각 행 합 [3 7]

# 전치
print(x)
# [[1 2]
#  [3 4]]

print(x.T)
# [[1 3]
#  [2 4]]

# 브로드캐스팅
# Numpy에서 shape이 다른 배열 간에도 산술 연산이 가능하게 하는 매커니즘
# 큰 배열을 대상으로 작은 배열을 여러 번 연산하고자 할 때

# 행렬 x의 각 행에 벡터 v를 더한 뒤, 그 결과를 행렬 y에 저장
x = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])
v = np.array([1, 0, 1])
y = np.empty_like(x)  # x와 동일한 shape을 가지며 비어있는 행렬 생성

# 반복문을 통해 행렬 x의 각 행에 벡터 v를 더하는 방법
for i in range(4):
    y[i, :] = x[i, :] + v

print(y)
# [[ 2  2  4]
#  [ 5  5  7]
#  [ 8  8 10]
#  [11 11 13]]

# 위의 방식대로 하면 'x'가 매우 큰 행렬이라면, 반복문을 이요한 위 코드는 매우 느려질 수 있다.
# 벡터 'v'를 행렬 'x'의 각 행에 더하는 것은 'v'를 여러 개 복사해 수직으로 쌓은 행렬 'vv'를 만들고
# 이 'vv'를 'x'에 더하는것과 동일하다.
# 이 과정을 아래의 코드로 구현
# 행렬 x의 각 행에 벡터 v를 더한 뒤, 그 결과를 행렬 y에 저장
x = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])
v = np.array([1, 0, 1])
vv = np.tile(v, (4, 1)) # v의 복사본 4개를 위로 차곡차곡 쌓은 것.
print(vv)
# [[1 0 1]
#  [1 0 1]
#  [1 0 1]
#  [1 0 1]]

y = x + vv  # x와 vv의 요소별 합
print(y)
# [[ 2  2  4]
#  [ 5  5  7]
#  [ 8  8 10]
#  [11 11 13]]

# 브로드캐스팅을 이용한다면 v의 복사본을 여러 개 만들지 않아도 동일한 연산 가능.
# 행렬 x의 각 행에 벡터 v를 더한 뒤, 그 결과를 행렬 y에 저장
x = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])
v = np.array([1, 0, 1])
y = x + v # 브로드캐스팅을 이용하여 v를 x의 각 행에 더하기
print(y)
# [[ 2  2  4]
#  [ 5  5  7]
#  [ 8  8 10]
#  [11 11 13]]

# 브로드캐스팅 응용 예시
# 벡터의 외적을 계산
v = np.array([1, 2, 3])  # v의 shape (3, )
w = np.array([4, 5])  # w의 shape (2, )

# 외적을 계산하기 위해, 먼저 v를 shape이 (3, 1)인 행벡터로 바꿔야 함.
# 그 다음 이것을 w에 맞춰 브로드캐스팅한 뒤 결과물로 shape이 (3, 2)인 행렬 얻음
print(np.reshape(v, (3, 1)) * w)
# [[ 4  5]
#  [ 8 10]
#  [12 15]]

# 벡터를 행렬의 각 행에 더하기
x = np.array([[1, 2, 3], [4, 5, 6]])
print(x.shape)  # (2, 3)
print(v.shape)  # (3, )
print(x + v)
# [[2 4 6]
#  [5 7 9]]




